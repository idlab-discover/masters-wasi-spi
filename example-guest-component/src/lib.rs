use wit_bindgen::generate;

// Generate bindings based on the 'app' world
generate!({
    path: "wit",
    world: "app",
    with: {
        "wasi:spi/spi": generate,
    }
});

// Use the types generated by the macro.
// We alias Operation to avoid ambiguity if needed, but here it's likely fine.
use crate::wasi::spi::spi::{SpiDevice as SpiDeviceHandle, Operation};

struct MyGuest;

// Implementing the Guest trait from the generated exports
// We use `self::exports` or just `exports` to refer to the generated module.
// Sometimes explicitly referencing it helps resolve ambiguity.

impl Guest for MyGuest {
    /// The entry point called by the Host.
    /// 'device' is an owned Resource passed from the Host.
    fn run(device: SpiDeviceHandle) {
        println!("\n--- [Guest] Starting SPI Driver Test ---");

        // TEST 1: Simple Write
        // --------------------
        println!("[Guest] Test 1: Write Command");
        let write_data = vec![0xCA, 0xFE, 0xBA, 0xBE];

        match device.write(&write_data) {
            Ok(_) => println!("  -> Write success: {:02X?}", write_data),
            Err(e) => eprintln!("  -> Write FAILED: {:?}", e),
        }

        // TEST 2: Simple Read
        // -------------------
        println!("\n[Guest] Test 2: Read Status");
        match device.read(4) {
            Ok(data) => println!("  -> Read success: {:02X?}", data),
            Err(e) => eprintln!("  -> Read FAILED: {:?}", e),
        }

        // TEST 3: Full Transaction
        // ------------------------
        println!("\n[Guest] Test 3: Transaction (Write Addr -> Read Data)");

        let ops = vec![
            Operation::Write(vec![0x75]), // Example Register Address
            Operation::Read(1),           // Read 1 byte
        ];

        match device.transaction(&ops) {
            Ok(results) => {
                if let Some(response) = results.get(1) {
                    println!("  -> Transaction success. Register Value: {:02X?}", response);
                } else {
                    println!("  -> Transaction success, but result list was empty/short.");
                }
            },
            Err(e) => eprintln!("  -> Transaction FAILED: {:?}", e),
        }

        println!("\n--- [Guest] Test Complete ---");
    }
}

// Export the implementation
export!(MyGuest);